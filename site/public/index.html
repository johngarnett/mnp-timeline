<!DOCTYPE html>
<html lang="en">
<head>
   <meta charset="UTF-8">
   <meta name="viewport" content="width=device-width, initial-scale=1.0">
   <title>MNP Match Timeline</title>
   <link href="https://unpkg.com/vis-timeline@7.7.3/styles/vis-timeline-graph2d.min.css" rel="stylesheet" />
   <style>
      * { box-sizing: border-box; margin: 0; padding: 0; }

      body {
         font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
         background: #1a1a2e;
         color: #e0e0e0;
         padding: 20px;
      }

      h1 {
         text-align: center;
         margin-bottom: 16px;
         font-size: 1.4em;
         color: #ccc;
      }

      #controls {
         text-align: center;
         margin-bottom: 16px;
      }

      #controls label { margin-right: 8px; font-size: 0.9em; }
      #controls select, #controls button {
         padding: 4px 10px;
         border-radius: 4px;
         border: 1px solid #444;
         background: #2a2a4a;
         color: #e0e0e0;
         font-size: 0.9em;
         margin-right: 6px;
      }
      #controls button {
         cursor: pointer;
         background: #3a3a6a;
      }
      #controls button:hover { background: #4a4aaa; }

      #timeline {
         background: #16213e;
         border-radius: 8px;
         padding: 8px;
         min-height: 400px;
      }

      #loading {
         text-align: center;
         padding: 40px;
         font-size: 1.1em;
         color: #888;
      }

      /* vis-timeline dark theme overrides */
      .vis-timeline {
         border: none;
         font-family: inherit;
      }
      .vis-panel.vis-bottom, .vis-panel.vis-center,
      .vis-panel.vis-left, .vis-panel.vis-right,
      .vis-panel.vis-top {
         border-color: #333;
      }
      .vis-time-axis .vis-text { color: #fff !important; fill: #fff !important; }
      .vis-time-axis .vis-grid.vis-minor { border-color: #2a2a4a; }
      .vis-time-axis .vis-grid.vis-major { border-color: #3a3a5a; }
      .vis-labelset .vis-label { color: #ccc; }
      .vis-foreground .vis-group { border-bottom: 1px solid #2a2a4a; }
      .vis-panel.vis-left { background: #1a1a30; }

      /* Nested group styling */
      .vis-label.vis-nesting-group .vis-inner {
         font-weight: bold;
         font-size: 0.95em;
         color: #fff;
      }
      .vis-ltr .vis-label.vis-nested-group .vis-inner {
         padding-left: 20px;
         font-size: 0.85em;
         color: #666;
      }

      /* Compact event bars */
      .vis-item .vis-item-content {
         padding: 1px 5px !important;
         font-size: 0.75em;
         line-height: 1.2;
      }

      /* Event type colors */
      .event-picking {
         background: #4a90d9 !important;
         border-color: #3a7bc8 !important;
      }
      .event-responding {
         background: #e8a838 !important;
         border-color: #d09520 !important;
      }
      .event-game {
         background: #5cb85c !important;
         border-color: #4cae4c !important;
         color: #fff !important;
         font-size: 0.56em;
         overflow: hidden;
      }
      .event-confirm-score {
         background: #9b59b6 !important;
         border-color: #8e44ad !important;
      }
      .event-confirm-lineup {
         background: #1abc9c !important;
         border-color: #16a085 !important;
      }

      /* Tooltip styling */
      .vis-tooltip {
         background: #2a2a4a !important;
         color: #e0e0e0 !important;
         border: 1px solid #555 !important;
         border-radius: 6px !important;
         padding: 8px 12px !important;
         font-size: 0.85em !important;
         box-shadow: 0 4px 12px rgba(0,0,0,0.5) !important;
         max-width: 320px !important;
      }
      .tooltip-title {
         font-weight: bold;
         margin-bottom: 4px;
         font-size: 1.05em;
      }
      .tooltip-time { color: #999; font-size: 0.9em; margin-bottom: 6px; }
      .score-table {
         border-collapse: collapse;
         width: 100%;
         margin-top: 4px;
      }
      .score-table th, .score-table td {
         padding: 2px 8px;
         text-align: left;
         border-bottom: 1px solid #444;
      }
      .score-table th { color: #999; font-size: 0.85em; }

      /* Round divider background bands */
      .round-divider {
         background: rgba(231, 76, 60, 0.3) !important;
         border-left: 2px solid rgba(231, 76, 60, 0.7);
         border-right: 2px solid rgba(231, 76, 60, 0.7);
         min-width: 18px !important;
         overflow: visible !important;
      }
      .round-divider .vis-item-overflow {
         overflow: visible !important;
      }
      .round-divider .vis-item-content {
         color: rgba(231, 76, 60, 0.9);
         font-size: 0.56em;
         font-weight: bold;
         white-space: nowrap;
         padding: 1px 4px;
         background: rgba(22, 33, 62, 0.85);
         border-radius: 3px;
      }

      /* Legend */
      #legend {
         display: flex;
         justify-content: center;
         gap: 16px;
         margin-bottom: 12px;
         flex-wrap: wrap;
      }
      .legend-item {
         display: flex;
         align-items: center;
         gap: 5px;
         font-size: 0.8em;
         color: #aaa;
      }
      .legend-dot {
         width: 12px;
         height: 12px;
         border-radius: 50%;
         display: inline-block;
      }
   </style>
</head>
<body>
   <h1>MNP Match Timeline</h1>

   <div id="controls">
      <label>Season: <select id="season"></select></label>
      <label>Week: <select id="week"></select></label>
      <label>Venue: <select id="venue"></select></label>
      <button id="loadBtn">Load</button>
   </div>

   <div id="legend">
      <span class="legend-item"><span class="legend-dot" style="background:#4a90d9"></span> Picking</span>
      <span class="legend-item"><span class="legend-dot" style="background:#e8a838"></span> Responding</span>
      <span class="legend-item"><span class="legend-dot" style="background:#5cb85c"></span> Game Reported</span>
      <span class="legend-item"><span class="legend-dot" style="background:#9b59b6"></span> Score Confirm</span>
      <span class="legend-item"><span class="legend-dot" style="background:#1abc9c"></span> Lineup Confirm</span>
      <span class="legend-item"><span style="display:inline-block;width:12px;height:12px;background:rgba(231,76,60,0.12);border-left:2px solid rgba(231,76,60,0.5);border-right:2px solid rgba(231,76,60,0.5)"></span> Round Break</span>
   </div>

   <div id="timeline">
      <div id="loading">Loading match data...</div>
   </div>

   <script src="https://unpkg.com/vis-timeline@7.7.3/standalone/umd/vis-timeline-graph2d.min.js"></script>
   <script>
      const TIMELINE_PADDING_MS = 5 * 60 * 1000
      const EVENT_MARKER_DURATION_MS = 30 * 1000
      const DEFAULT_SEASON = '23'
      const DEFAULT_WEEK = '3'
      const DEFAULT_VENUE = 'T4B'

      let timeline = null

      const seasonEl = document.getElementById('season')
      const weekEl = document.getElementById('week')
      const venueEl = document.getElementById('venue')

      function populateSelect(el, values, defaultVal) {
         el.innerHTML = ''
         values.forEach(v => {
            const opt = document.createElement('option')
            opt.value = v
            opt.textContent = v
            el.appendChild(opt)
         })
         if (defaultVal && values.map(String).includes(String(defaultVal))) {
            el.value = defaultVal
         }
      }

      async function fetchFilters(opts = {}) {
         const params = new URLSearchParams()
         if (opts.season) params.set('season', opts.season)
         if (opts.week) params.set('week', opts.week)
         const res = await fetch(`/api/filters?${params}`)
         return res.json()
      }

      async function loadSeasons() {
         const { seasons } = await fetchFilters()
         populateSelect(seasonEl, seasons, DEFAULT_SEASON)
         await loadWeeks()
      }

      async function loadWeeks() {
         const { weeks } = await fetchFilters({ season: seasonEl.value })
         populateSelect(weekEl, weeks, DEFAULT_WEEK)
         await loadVenues()
      }

      async function loadVenues() {
         const { venues } = await fetchFilters({ season: seasonEl.value, week: weekEl.value })
         const allOption = '(all)'
         populateSelect(venueEl, [allOption, ...venues], DEFAULT_VENUE)
         if (!venues.map(String).includes(String(DEFAULT_VENUE))) {
            venueEl.value = allOption
         }
      }

      seasonEl.addEventListener('change', async () => {
         await loadWeeks()
      })

      weekEl.addEventListener('change', async () => {
         await loadVenues()
      })

      function formatScore(scoreStr) {
         return parseInt(scoreStr, 10).toLocaleString()
      }

      function gameTooltip(machine, round) {
         const playerRows = machine.players.map(p =>
            `<tr><td>${p.name || 'P' + p.player}</td><td>${formatScore(p.score)}</td></tr>`
         ).join('')
         return `<div class="tooltip-title">${machine.name}</div>` +
            `<div class="tooltip-time">Round ${round} &middot; ${machine.reported.local}</div>` +
            `<table class="score-table"><tr><th>Player</th><th>Score</th></tr>${playerRows}</table>`
      }

      function eventTooltip(label, timestamp) {
         return `<div class="tooltip-title">${label}</div>` +
            `<div class="tooltip-time">${timestamp.local}</div>`
      }

      function confirmTooltip(side, level, timestamp) {
         const sideLabel = side === 'Left' ? 'Away (Left)' : 'Home (Right)'
         return `<div class="tooltip-title">${level} Confirm &mdash; ${sideLabel}</div>` +
            `<div class="tooltip-time">${timestamp.local}</div>`
      }

      function buildTimeline(matches) {
         const groups = new vis.DataSet()
         const items = new vis.DataSet()
         let itemId = 1

         matches.forEach((match, mi) => {
            const matchGroupId = `match-${mi}`
            const matchLabel = `${match.away}@${match.home}`

            groups.add({
               id: matchGroupId,
               content: matchLabel,
               nestedGroups: match.rounds.map((_, ri) => `${matchGroupId}-r${ri + 1}`)
            })

            // Match-level lineup confirmations
            if (match.confirmLeft) {
               items.add({
                  id: itemId++,
                  group: matchGroupId,
                  start: new Date(match.confirmLeft.epoch),
                  end: new Date(match.confirmLeft.epoch + EVENT_MARKER_DURATION_MS),
                  type: 'range',
                  className: 'event-confirm-lineup',
                  title: confirmTooltip('Left', 'Lineup', match.confirmLeft),
                  content: ''
               })
            }
            if (match.confirmRight) {
               items.add({
                  id: itemId++,
                  group: matchGroupId,
                  start: new Date(match.confirmRight.epoch),
                  end: new Date(match.confirmRight.epoch + EVENT_MARKER_DURATION_MS),
                  type: 'range',
                  className: 'event-confirm-lineup',
                  title: confirmTooltip('Right', 'Lineup', match.confirmRight),
                  content: ''
               })
            }

            // Round divider background bands (scoped to this match)
            for (let ri = 0; ri < match.rounds.length - 1; ri++) {
               const endEpoch = getRoundEndEpoch(match.rounds[ri])
               const startEpoch = getRoundStartEpoch(match.rounds[ri + 1])
               if (endEpoch && startEpoch) {
                  const nextRound = match.rounds[ri + 1].round
                  items.add({
                     id: itemId++,
                     group: matchGroupId,
                     start: new Date(endEpoch),
                     end: new Date(startEpoch),
                     type: 'background',
                     className: 'round-divider',
                     content: `${nextRound}`
                  })
               }
            }

            match.rounds.forEach((round, ri) => {
               const roundGroupId = `${matchGroupId}-r${ri + 1}`
               groups.add({
                  id: roundGroupId,
                  content: `Round ${round.round}`
               })

               // Picking
               if (round.picking) {
                  const pickEnd = round.responding
                     ? round.responding.epoch
                     : round.picking.epoch + EVENT_MARKER_DURATION_MS
                  items.add({
                     id: itemId++,
                     group: roundGroupId,
                     start: new Date(round.picking.epoch),
                     end: new Date(pickEnd),
                     type: 'range',
                     className: 'event-picking',
                     title: eventTooltip('Picking', round.picking),
                     content: ''
                  })
               }

               // Responding
               if (round.responding) {
                  items.add({
                     id: itemId++,
                     group: roundGroupId,
                     start: new Date(round.responding.epoch),
                     end: new Date(round.responding.epoch + EVENT_MARKER_DURATION_MS),
                     type: 'range',
                     className: 'event-responding',
                     title: eventTooltip('Responding', round.responding),
                     content: ''
                  })
               }

               // Games (machines)
               const GAME_START_OFFSET_MS = 60 * 1000
               round.machines.forEach(machine => {
                  if (machine.reported) {
                     const gameStart = round.responding
                        ? round.responding.epoch + GAME_START_OFFSET_MS
                        : machine.reported.epoch
                     items.add({
                        id: itemId++,
                        group: roundGroupId,
                        start: new Date(gameStart),
                        end: new Date(machine.reported.epoch),
                        type: 'range',
                        className: 'event-game',
                        title: gameTooltip(machine, round.round),
                        content: machine.name
                     })
                  }
               })

               // Round-level score confirmations
               if (round.confirmLeft) {
                  items.add({
                     id: itemId++,
                     group: roundGroupId,
                     start: new Date(round.confirmLeft.epoch),
                     end: new Date(round.confirmLeft.epoch + EVENT_MARKER_DURATION_MS),
                     type: 'range',
                     className: 'event-confirm-score',
                     title: confirmTooltip('Left', 'Score', round.confirmLeft),
                     content: ''
                  })
               }
               if (round.confirmRight) {
                  items.add({
                     id: itemId++,
                     group: roundGroupId,
                     start: new Date(round.confirmRight.epoch),
                     end: new Date(round.confirmRight.epoch + EVENT_MARKER_DURATION_MS),
                     type: 'range',
                     className: 'event-confirm-score',
                     title: confirmTooltip('Right', 'Score', round.confirmRight),
                     content: ''
                  })
               }
            })
         })

         // Compute time range
         const allTimes = items.get().map(i => i.start.getTime())
         const minTime = Math.min(...allTimes) - TIMELINE_PADDING_MS
         const maxTime = Math.max(...allTimes) + TIMELINE_PADDING_MS

         const container = document.getElementById('timeline')
         container.innerHTML = ''

         const options = {
            start: new Date(minTime),
            end: new Date(maxTime),
            min: new Date(minTime - TIMELINE_PADDING_MS * 4),
            max: new Date(maxTime + TIMELINE_PADDING_MS * 4),
            zoomMin: 60 * 1000,
            zoomMax: 12 * 60 * 60 * 1000,
            editable: false,
            selectable: false,
            tooltip: {
               followMouse: true,
               overflowMethod: 'flip',
               template: function(data) {
                  return data.title || ''
               }
            },
            orientation: { axis: 'top' },
            groupOrder: 'id',
            margin: { item: { horizontal: 0, vertical: 3 } }
         }

         timeline = new vis.Timeline(container, items, groups, options)
      }

      function getRoundEndEpoch(round) {
         const candidates = []
         if (round.confirmLeft) candidates.push(round.confirmLeft.epoch)
         if (round.confirmRight) candidates.push(round.confirmRight.epoch)
         round.machines.forEach(m => {
            if (m.reported) candidates.push(m.reported.epoch)
         })
         return candidates.length > 0 ? Math.max(...candidates) : null
      }

      function getRoundStartEpoch(round) {
         if (round.picking) return round.picking.epoch
         if (round.responding) return round.responding.epoch
         return null
      }

      async function loadMatches() {
         const season = seasonEl.value
         const week = weekEl.value
         const venue = venueEl.value

         document.getElementById('loading')?.remove()
         document.getElementById('timeline').innerHTML = '<div id="loading">Loading...</div>'

         try {
            let url = `/api/matches?season=${season}&week=${week}`
            if (venue && venue !== '(all)') {
               url += `&venue=${encodeURIComponent(venue)}`
            }
            const res = await fetch(url)
            if (!res.ok) {
               const err = await res.json()
               throw new Error(err.error || `HTTP ${res.status}`)
            }
            const matches = await res.json()
            if (matches.length === 0) {
               document.getElementById('timeline').innerHTML =
                  '<div id="loading">No matches found for this filter.</div>'
               return
            }
            buildTimeline(matches)
         } catch (err) {
            document.getElementById('timeline').innerHTML =
               `<div id="loading" style="color:#e74c3c">Error: ${err.message}</div>`
         }
      }

      document.getElementById('loadBtn').addEventListener('click', loadMatches)

      // Initialize dropdowns then auto-load
      loadSeasons().then(() => loadMatches())
   </script>
</body>
</html>
